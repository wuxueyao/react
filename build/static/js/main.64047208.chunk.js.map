{"version":3,"sources":["ShowTime.js","TodoList/Todoinput.js","TodoList/Todoing.js","TodoList/Todolist.js","Request.js","index.js"],"names":["React","Component","Todoinput","handleInput","e","keyCode","props","addTodo","target","value","handleChange","setState","name","parseInt","state","n1","n2","htmlFor","onChange","this","onKeyDown","type","Todoing","todo","map","item","idx","key","onClick","delTodo","defaultProps","a","Request","data","fetch","method","body","then","res","json","result","console","log","index","album_title","author","ReactDOM","render","word","document","getElementById","createElement","obj","container","fr","createDocumentFragment","ele","className","i","length","txt","createTextNode","appendChild","id","class","children"],"mappings":"iQAGuBA,IAAMC,U,cCYRC,E,YACjB,aAAc,IAAD,8BACT,+CAMJC,YAAc,SAACC,GACM,KAAdA,EAAEC,SACD,EAAKC,MAAMC,QAAQH,EAAEI,OAAOC,QATvB,EAabC,aAAc,SAACN,GACX,EAAKO,SAAL,eACKP,EAAEI,OAAOI,KAAQC,SAAST,EAAEI,OAAOC,UAbxC,EAAKK,MAAM,CACPC,GAAG,EACHC,GAAG,GAJE,E,sEAkBH,IAAD,OACL,OACI,6BAKI,2BAAOC,QAAQ,OAAf,sBACA,2BAAOL,KAAK,KAAKM,SAAU,SAACd,GAAD,OAAK,EAAKM,aAAaN,IAAIK,MAAOU,KAAKL,MAAMC,GAAIK,UAAWD,KAAKhB,YAAckB,KAAK,SANnH,IAQI,2BAAOT,KAAK,KAAKM,SAAU,SAACd,GAAD,OAAK,EAAKM,aAAaN,IAAIK,MAAOU,KAAKL,MAAME,GAAII,UAAWD,KAAKhB,YAAckB,KAAK,SAC/G,2BAAIF,KAAKL,MAAMC,GAAGI,KAAKL,MAAME,IAE7B,qD,GAhCuBf,aCblBqB,E,iLACP,IAAD,OACL,OACI,6BACI,wDACA,4BAIQH,KAAKb,MAAMiB,KAAKC,KAAI,SAACC,EAAKC,GAAN,OAAY,wBAAIC,IAAKD,GAAMD,EAAf,OAAwB,4BAAQG,QAAS,kBAAI,EAAKtB,MAAMuB,QAAQH,KAAxC,2B,GAT3CzB,aAoBrCqB,EAAQQ,aAAa,CACjBP,KAAK,CAAC,EAAE,EAAE,EAAE,GACZQ,EAAI,KCnB8B9B,Y,UCFjB+B,E,YACjB,aAAc,IAAD,8BACT,+CACKlB,MAAQ,CACTmB,KAAO,IAHF,E,iFAOO,IAAD,OAGfC,MAAM,sDACN,CAACC,OAAO,OAAOC,KAAK,eAEnBC,MAAK,SAACC,GACH,OAAOA,EAAIC,UAEdF,MAAK,SAACC,GACH,EAAK3B,SAAS,CACVsB,KAAKK,EAAIE,SAEbC,QAAQC,IAAIJ,Q,+BAYhB,OACI,6BACI,wDACA,4BAEQnB,KAAKL,MAAMmB,KAAKT,KACZ,SAACC,EAAKkB,GAAN,OACI,wBAAIhB,IAAKgB,GACL,iDAAQlB,EAAKmB,aACb,gDAAOnB,EAAKoB,kB,GA1CX5C,aCyDrC6C,IAASC,OAAO,kBAAC,EAAD,CAASC,KAAK,UAAUC,SAASC,eAAe,SAyDtDlD,IAAMmD,cACZ,MACA,CAAC,GAAK,OACN,QACAnD,IAAMmD,cACF,KACA,CAAC,GAAK,KACN,WAuBR,SAASJ,EAAOK,EAAIC,GAAW,IACtBhC,EAAc+B,EAAd/B,KAAKf,EAAS8C,EAAT9C,MAENgD,EAAKL,SAASM,yBAEdC,EAAMP,SAASE,cAAc9B,GACjC,IAAI,IAAII,KAAQnB,EACZ,GAAY,UAATmB,EACC+B,EAAIC,UAAYnD,EAAMmB,QACpB,GAAY,aAATA,EACL,IAAI,IAAIiC,EAAE,EAAEA,EAAEpD,EAAMmB,GAAMkC,OAAOD,IAC7B,GAA6B,kBAAnBpD,EAAMmB,GAAMiC,GAClBX,EAAOzC,EAAMmB,GAAMiC,GAAGF,OACrB,CACD,IAAII,EAAMX,SAASY,eAAevD,EAAMmB,GAAMiC,IAC9CF,EAAIM,YAAYF,QAIxBJ,EAAI/B,GAAQnB,EAAMmB,GAK1B6B,EAAGQ,YAAYN,GACfH,EAAUS,YAAYR,GAE1BP,CA/CU,CACN1B,KAAM,MACNf,MAAO,CACHyD,GAAI,MACJC,MAAO,MACPC,SAAU,CAAC,QAAQ,CACf5C,KAAM,KACNf,MAAO,CACHyD,GAAI,IACJC,MAAO,IACPC,SAAU,CAAC,cAqChBhB,SAASC,eAAe,W","file":"static/js/main.64047208.chunk.js","sourcesContent":["import React,{Component,Fragment} from 'react';\r\n//类定义组件\r\n//export default class…… 这样写可以一边定义一边导出\r\nclass ShowTime extends React.Component{//第一行{}引入了组件名，这里可以直接写名\r\n    constructor(props){\r\n        super(props);//将父类的this传给子类，必须有\r\n        this.state={\r\n            time:new Date().toLocaleString()\r\n        }\r\n        //通过bind绑定this\r\n        this.handleClick = this.handleClick.bind(this);\r\n        console.log('constructor',this.props.word);\r\n    }\r\n    componentDidMount(){\r\n        console.log('componentDidMount');\r\n        setTimeout(()=>{\r\n            console.log(1);\r\n            this.setState({\r\n                time: new Date().toLocaleDateString()\r\n            })\r\n        },1000)\r\n    }\r\n    shouldComponentUpdate(){\r\n        return true;\r\n    }\r\n    getSnapshotBeforeUpdate(){\r\n        console.log('getsnapshot');\r\n    }\r\n    componentDidUpdate(){\r\n        console.log('didupdate');\r\n    }\r\n    \r\n    //虽然是一个函数，但在类里，是类的一个方法，不需要写function\r\n    handleClick = (id,e)=>{\r\n        console.log(this);\r\n        console.log('点击成功');\r\n    }\r\n    divClick = (num,e)=>{\r\n        console.log(num,e);\r\n        console.log('时樾哥哥呀！');\r\n    }\r\n    // handleClick(){\r\n    //     console.log(this);\r\n    //     console.log('点击成功');\r\n    // }\r\n\r\n    render(){\r\n        console.log('render');\r\n\r\n        return (//只能返回一个标签，如果要很多就得在外边包一个\r\n            <Fragment>\r\n                {/* 外层如果用div标签的话，就会在页面中有多余结构，这样不会有 */}\r\n\r\n                {/* <div onClick={this.handleClick}>{this.state.time}</div> */}\r\n                \r\n                {/* 1是实参，ev是事件对象 */}\r\n                <div onClick={(ev)=>this.handleClick(1,ev)}>{this.state.time}</div>\r\n\r\n                {/* 也可以不用提前声明，直接写个箭头函数 */}\r\n                {/* <div onClick={()=>{console.log(1);}}>{this.state.time}</div> */}\r\n                \r\n                {/* <div>hello{this.props.word}</div> */}\r\n                <div onClick={this.divClick.bind(this,333)}>hello{this.props.word}</div>\r\n            </Fragment>\r\n        );\r\n    }\r\n}\r\n\r\n/*-------导出类---------*/\r\n\r\n//默认导出，默认导出引用的时候可以自己起名字\r\n//export default ShowTime;\r\n\r\n//命名导出，可写多个export\r\nexport {ShowTime}; //可以把多个类依次导出，放进去逗号隔开\r\n\r\n//被调用的组件是子组件","import React, { Component } from 'react'\r\n\r\n/**\r\n * 子组件---->父组件传递数据，调用子组件时往子组件传递一个函数\r\n * 子组件通过props调用该函数\r\n */\r\n\r\n/**\r\n * 受控组件和非受控组件\r\n * 受控组件：value值被react的状态控制\r\n *          可以方便拿到input框的值、实时获取或处理输入的内容\r\n *         （每输入一次就会变推荐使用受控组件）\r\n * 非受控组件：代码简单、比较适用于一次性获取表单的值\r\n */\r\n/* 01. 受控组件*/\r\nexport default class Todoinput extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            n1:0,\r\n            n2:0\r\n        }\r\n    }\r\n    handleInput = (e)=>{\r\n        if(e.keyCode === 13){\r\n            this.props.addTodo(e.target.value);\r\n            // this.props.addTodo(this.state.value);\r\n        }\r\n    }\r\n    handleChange =(e) =>{\r\n        this.setState({\r\n            [e.target.name] : parseInt(e.target.value)\r\n        })\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                {/* input属性加上value值就不能改变了 */}\r\n                {/* <input onChange={(e)=>this.handleInput} value='dwefd' type=\"text\"/> */}\r\n                {/* <input onKeyDown={this.handleInput} type=\"text\"/>\r\n                <input onKeyDown={this.handleInput} type=\"text\"/> */}\r\n                <label htmlFor=\"inp\">输入：</label>\r\n                <input name=\"n1\" onChange={(e)=>this.handleChange(e)} value={this.state.n1} onKeyDown={this.handleInput}  type=\"text\"/>\r\n                +\r\n                <input name=\"n2\" onChange={(e)=>this.handleChange(e)} value={this.state.n2} onKeyDown={this.handleInput}  type=\"text\"/>\r\n                <p>{this.state.n1+this.state.n2}</p>\r\n                \r\n                <button>查询</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n/* 02. 非受控组件*/\r\n// export default class Todoinput extends Component {\r\n//     componentDidMount(){\r\n//         console.log(this.inp.value);\r\n//         console.log(this.refs);\r\n//     }\r\n//     search =()=>{\r\n//         console.log(this.inp.value);\r\n//     }\r\n//     render() {\r\n//         return ( \r\n//             <div>\r\n//                 <input ref={(inp)=>this.inp = inp} type=\"text\"/>\r\n//                 <button onClick={this.search}>查询</button>\r\n//             </div>\r\n//         )\r\n//     }\r\n// }\r\n\r\n","import React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nexport default class Todoing extends Component {\r\n    render() {\r\n        return (\r\n            <div>\r\n                <h1>正在进行</h1>\r\n                <ul>\r\n                    {/* arr.foreach\\some\\every\\find\\map\\reduce */}\r\n                    \r\n                    {\r\n                        this.props.todo.map((item,idx)=><li key={idx}>{item}----<button onClick={()=>this.props.delTodo(idx)}>删除 </button></li>)\r\n                    }\r\n                </ul>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nTodoing.propTypes={\r\n    todo:PropTypes.array\r\n}\r\nTodoing.defaultProps={\r\n    todo:[2,3,4,5],\r\n    a : 100\r\n}\r\n","import React, { Component } from 'react';\r\nimport Todoinput from './Todoinput';\r\nimport Todoing from './Todoing';\r\n\r\n//事件的绑定和交互\r\nexport default class Todolist extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state = {\r\n            todo:[1,2,3]\r\n        }\r\n\r\n        //深拷贝\r\n        // var arr = [1,2,{a:100}];\r\n        // //var b = [...arr];\r\n        // var b = JSON.parse(JSON.stringify(arr));\r\n        // b[2].a = 200;\r\n        // console.log(arr);\r\n\r\n        //对象的拷贝\r\n        var a = {a1:100,a2:300};\r\n        var b = {b:200};\r\n        // var o = Object.assign(a,b);  //a和o一样，没有创建新的对象\r\n        var o = Object.assign({},a,b);  //创建了一个新的对象，放进去的，a还是原来的\r\n        console.log(o);\r\n        console.log(a);\r\n        console.log(o === a);\r\n\r\n        //遍历对象\r\n        Object.keys(a).forEach((item)=>{\r\n            console.log(item); //属性名称\r\n            console.log(a[item]); //属性值\r\n        })\r\n\r\n        //会把不需要的也遍历出来，尽量不要使用for...in遍历\r\n        for(var item in a){\r\n            console.log(item);\r\n        }\r\n\r\n\r\n    }\r\n    addItem = (msg)=>{\r\n        // this.state.todo.push(msg);\r\n        // console.log(this.state.msg);\r\n\r\n        // setState会引起一系列生命周期的改变\r\n        this.setState({\r\n            todo:[...this.state.todo,msg]\r\n        })\r\n        console.log(msg);\r\n    }\r\n    delItem = (a)=>{\r\n        /* this.state.todo.splice(a,1); //不要对状态直接进行处理，不建议写这个\r\n         this.setState({\r\n             todo: this.state.todo\r\n         })*/\r\n\r\n         /**深拷贝\\浅拷贝\r\n         * 状态（state）：\r\n         * 1.不要直接改变、处理状态\r\n         * 2.setState是异步的\r\n         */\r\n\r\n         //1.\r\n        var todo = [...this.state.todo];\r\n        todo.splice(a,1);\r\n\r\n        //2.\r\n        //这个拿到的值是上一个state的值加一\r\n        // this.setState((state,；props)=>({todo:state.todo+1})); \r\n\r\n        this.setState({\r\n            todo:todo\r\n        })\r\n        console.log(a);\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Todoinput addTodo = {this.addItem}/>\r\n                <Todoing todo={this.state.todo} delTodo ={this.delItem}/>\r\n                {/* 函数名和属性名没有关系 */}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import React, { Component } from 'react'\r\nimport Axios from 'axios'\r\n// 上边的接口都可以用\r\nexport default class Request extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state = {\r\n            data : []\r\n        }\r\n        // 组件外无法修改state\r\n    }\r\n    componentDidMount(){\r\n        //用fetch写原生的方法\r\n        //先写接口地址\r\n        fetch('https://api.apiopen.top/musicRankingsDetails?type=1',\r\n        {method:'post',body:'{name:111}'}\r\n        )\r\n        .then((res)=>{\r\n            return res.json();\r\n        })\r\n        .then((res)=>{\r\n            this.setState({\r\n                data:res.result\r\n            })\r\n            console.log(res);\r\n        });\r\n\r\n        // Axios.get('https://api.apiopen.top/musicRankingsDetails?type=1')\r\n        // .then((res)=>{\r\n        //     console.log(res);\r\n        //     this.setState({\r\n        //         data:res.data.result\r\n        //     })\r\n        // })\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <h1>请求接口</h1>\r\n                <ul>\r\n                    {\r\n                        this.state.data.map(\r\n                            (item,index)=>(\r\n                                <li key={index}>\r\n                                    <h2>歌名：{item.album_title}</h2>\r\n                                    <p>歌手：{item.author}</p>\r\n                                </li>\r\n                            )\r\n                        )\r\n                    }\r\n                </ul>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport {ShowTime} from './ShowTime'; //如果引入的是js后缀名可以省略，别的不可以\nimport Todolist from './TodoList/Todolist';\nimport Request from './Request';\n//这种写法是命名导出，默认导出不需要写{},只需要起个名字就行，但最好和那个类一样的名字\n\n/*--------------------------1.自定义组件----------------------------- */\n/**\n * 类定义组件(有生命周期函数)\n * 当只是渲染结构，没有js逻辑功能的时候\n */\n// class Hello extends React.Component{//第一行{}引入了组件名，这里可以直接写名\n//     constructor(props){\n//         super(props);//将父类的this传给子类，必须有\n//         this.state={\n//             time:new Date().toLocaleString()\n//         }\n//         console.log('constructor',this.props.word);\n//     }\n//     componentDidMount(){\n//         console.log('componentDidMount');\n//         setTimeout(()=>{\n//             console.log(1);\n//             this.setState({\n//                 time: new Date().toLocaleDateString()\n//             })\n//         },1000)\n//     }\n//     shouldComponentUpdate(){\n//         return true;\n//     }\n//     getSnapshotBeforeUpdate(){\n//         console.log('getsnapshot');\n//     }\n//     componentDidUpdate(){\n//         console.log('didupdate');\n//     }\n//     render(){\n//         console.log('render');\n\n//         return (//只能返回一个标签，如果要很多就得在外边包一个\n//             <Fragment>\n//                 {/* 外层如果用div标签的话，就会在页面中有多余结构，这样不会有 */}\n//                 <div>{this.state.time}</div>\n//                 <div>hello{this.props.word}</div>\n//             </Fragment>\n//         );\n//     }\n// }\n\n/**\n * 组件交互\n * 父组件--->子组件：调用时在子组件上添加属性\n * 在子组件中通过props获取数据\n */\n\n //这里要和你要展示的js文件对应\nReactDOM.render(<Request word=\"react\"/>,document.getElementById(\"root\"));\n//绿色的写什么，页面就会显示什么\n\n/**\n * 函数定义组件(无生命周期函数)\n * 当只是渲染结构时：\n */\n// function Todo(props){\n//     return(\n//         <div>\n//             {/*条件渲染*/}\n//             {/*1. if else */}\n//             {props.list.length>=5?<h1>todo</h1>:''}\n\n//             {/*2. if */}\n//             {props.list.length>=5&&<h1>todo</h1>}\n//             <ul>\n//                 {/*循环渲染*/}\n//                 {\n//                     //函数可以写成箭头函数\n//                     props.list.map(function(item,index){\n//                         if(index%2 === 0){\n//                             return <li key={item}>{item}</li>\n//                         }\n//                     })\n\n//                     /**箭头函数和条件语句\n//                      * props.list.map(\n//                      *   (item,index)=> index%2===0 && <li key={item}>{item}</li>\n//                      *)\n//                      */\n//                 }\n//             </ul>\n//         </div>\n//     )\n// }\n// var item = [1,2,3,4,5];\n// ReactDOM.render(<Todo list={item}/>,document.getElementById('root'));\n\n\n\n\n/**\n * react元素创建后不可改变\n */\n// function tick(){\n//     var e = <div>\n//         <p>当前时间</p>\n//         <p>当前时间</p>\n//         <h1>{new Date().toLocaleDateString()}</h1>\n//     </div>;\n//     ReactDOM.render(e,document.getElementById('root'));\n// }\n// tick();\n// setInterval(tick,1000);\n\n//jsx表达式会被react转成一个对象，类似下面声明的obj对象\nvar ele = React.createElement(\n    'div',\n    {'id':'box'},\n    'hello',\n    React.createElement(\n        'h1',\n        {'id':'h'},\n        'react'\n    )\n);\nvar obj = {\n    type: 'div',\n    props: {\n        id: 'box',\n        class: 'box',\n        children: ['hello',{\n            type: 'h1',\n            props: {\n                id: 'h',\n                class: 'h',\n                children: ['react']\n            }\n        }]\n    }\n}\n\n\n/**\n * 自己声明render函数，实现页面渲染\n */\nfunction render(obj,container){\n    var {type,props} = obj;\n    // 文档碎片（可以把所有要添加的节点先放在这里，然后一起添加）\n    var fr = document.createDocumentFragment();\n\n    var ele = document.createElement(type);\n    for(var item in props){\n        if(item === 'class'){\n            ele.className = props[item];\n        }else if(item === 'children'){\n            for(var i=0;i<props[item].length;i++){\n                if(typeof props[item][i] === 'object'){\n                    render(props[item][i],ele);\n                }else{\n                    var txt = document.createTextNode(props[item][i]);\n                    ele.appendChild(txt);\n                }\n            }\n        }else{\n            ele[item] = props[item];\n        }\n    }\n\n\n    fr.appendChild(ele);\n    container.appendChild(fr);\n}\nrender(obj,document.getElementById('root'));\n// render(obj,document.getElementById('root'));\n\n//var e = <h1>hello</h1>\n// ReactDOM.render(ele,document.getElementById('root'));\n\n/*---------------------2.性能问题及优化方法-------------- */\n\n/**01.\n * 加载html文件、浏览器解析html生成DOM树\n * link加载css文件、解析css规则、和DOM树结合生成render tree（渲染树）、\n * 浏览器渲染引擎渲染render tree\n */\n\n/**02.\n * 页面回流（重排）：内容改变、大小改变、结构改变\n * 页面重绘：把字体颜色、背景颜色等样式改变\n * \n * 但是display、width、height、font-size这些，每次改变都会进行重排，\n * 所以最好声明一个css类，每次要改这些样式的时候，就加个类名，这样如果同时\n * 改这四个样式的时候，页面只会回流一次，如果通过元素获取来改变的话，\n * 四个样式就会回流四次。\n * \n * 除了上边，还有node.offsetLeft、nodesetWidth 等，这些每次在获取的时候\n * 也会引起页面回流，以便获取最新的内容。这些都要慎用。\n */\n\n// document.body.style.width = '100px';\n// document.body.style.height = '100px';\n//.change{\n//     width: 100px;\n//     height: 100px;\n// }\n// document.body.className = 'change';\n\n// var root = document.getElementById('root');\n// var width = root.offsetWidth; //*这样不会造成多余的页面回流\n// setInterval(function(){\n//     width += 1; //*\n//     root.style.width = width +'px'; //*\n\n//     //root.style.width = root.offsetWidth + 1 +'px';\n//     //这里页面每次获取都要回流，但是赋值肯定是会回流的\n// },100)\n\n\n /**03.\n  * 文档碎片就相当于是下边这样的，先把要增加的都放一起\n  * var str = '<h1>hello</h1>'+'';\n  * ele.innerHTML = str;\n  */\n\n/**04.\n * 对节点的操作先用变量代替\n */\n// console.time('a');\n// var str = '';\n// for(var i=0;i<1000;i++){\n//     str += '<li>'+i+'</li>';\n// }\n// document.body.innerHTML = str;\n// console.timeEnd('a');"],"sourceRoot":""}